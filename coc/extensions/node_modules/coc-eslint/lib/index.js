"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const utils_1 = require("./utils");
const defaultLanguages = ['javascript', 'javascriptreact'];
var Is;
(function (Is) {
    const toString = Object.prototype.toString;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
})(Is || (Is = {}));
var DirectoryItem;
(function (DirectoryItem) {
    function is(item) {
        let candidate = item;
        return (candidate &&
            Is.string(candidate.directory) &&
            (Is.boolean(candidate.changeProcessCWD) ||
                candidate.changeProcessCWD === void 0));
    }
    DirectoryItem.is = is;
})(DirectoryItem || (DirectoryItem = {}));
var NoConfigRequest;
(function (NoConfigRequest) {
    NoConfigRequest.type = new vscode_languageserver_protocol_1.RequestType('eslint/noConfig');
})(NoConfigRequest || (NoConfigRequest = {}));
var NoESLintLibraryRequest;
(function (NoESLintLibraryRequest) {
    NoESLintLibraryRequest.type = new vscode_languageserver_protocol_1.RequestType('eslint/noLibrary');
})(NoESLintLibraryRequest || (NoESLintLibraryRequest = {}));
const exitCalled = new vscode_languageserver_protocol_1.NotificationType('eslint/exitCalled');
function createDefaultConfiguration() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let { root } = coc_nvim_1.workspace;
        let configFiles = [
            '.eslintrc.js',
            '.eslintrc.yaml',
            '.eslintrc.yml',
            '.eslintrc',
            '.eslintrc.json'
        ];
        for (let configFile of configFiles) {
            if (fs_1.default.existsSync(path_1.default.join(root, configFile))) {
                coc_nvim_1.workspace.openResource(vscode_uri_1.default.file(root).toString()).catch(_e => {
                    // noop
                });
                return;
            }
        }
        const eslintCommand = yield utils_1.findEslint(root);
        yield coc_nvim_1.workspace.nvim.call('coc#util#open_terminal', [{
                cmd: eslintCommand + ' --init',
                cwd: root
            }]);
    });
}
function shouldBeValidated(textDocument) {
    let config = coc_nvim_1.workspace.getConfiguration('eslint', textDocument.uri);
    if (!config.get('enable', true))
        return false;
    let filetypes = config.get('filetypes', defaultLanguages);
    return filetypes.indexOf(textDocument.languageId) !== -1;
}
function activate(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let { subscriptions } = context;
        const config = coc_nvim_1.workspace.getConfiguration().get('eslint', {});
        const filetypes = config.filetypes || ['javascript', 'javascriptreact'];
        const selector = filetypes.reduce((res, filetype) => {
            return res.concat([{ language: filetype, scheme: 'file' }, { language: filetype, scheme: 'untitled' }]);
        }, []);
        let serverOptions = {
            module: context.asAbsolutePath('./lib/server/index.js'),
            args: ['--node-ipc'],
            transport: coc_nvim_1.TransportKind.ipc,
            options: {
                cwd: coc_nvim_1.workspace.root,
                execArgv: config.execArgv
            }
        };
        const syncedDocuments = new Map();
        let clientOptions = {
            documentSelector: selector,
            synchronize: {
                configurationSection: 'eslint',
                fileEvents: [
                    coc_nvim_1.workspace.createFileSystemWatcher('**/.eslintr{c.js,c.yaml,c.yml,c,c.json}'),
                    coc_nvim_1.workspace.createFileSystemWatcher('**/.eslintignore'),
                    coc_nvim_1.workspace.createFileSystemWatcher('**/package.json')
                ]
            },
            outputChannelName: 'eslint',
            initializationOptions: config.initializationOptions,
            diagnosticCollectionName: 'eslint',
            initializationFailedHandler: error => {
                coc_nvim_1.workspace.showMessage(`Eslint server initialization failed: ${error.message}.`, 'error');
                return false;
            },
            middleware: {
                didOpen: (document, next) => {
                    if (shouldBeValidated(document)) {
                        next(document);
                        syncedDocuments.set(document.uri.toString(), document);
                        return;
                    }
                },
                didChange: (event, next) => {
                    if (syncedDocuments.has(event.textDocument.uri)) {
                        next(event);
                    }
                },
                didClose: (document, next) => {
                    let uri = document.uri.toString();
                    if (syncedDocuments.has(uri)) {
                        syncedDocuments.delete(uri);
                        next(document);
                    }
                },
                provideCodeActions: (document, range, context, token, next) => {
                    if (!syncedDocuments.has(document.uri.toString()) || !context.diagnostics || context.diagnostics.length === 0) {
                        return [];
                    }
                    let eslintDiagnostics = [];
                    for (let diagnostic of context.diagnostics) {
                        if (diagnostic.source === 'eslint') {
                            eslintDiagnostics.push(diagnostic);
                        }
                    }
                    if (eslintDiagnostics.length === 0) {
                        return [];
                    }
                    let newContext = Object.assign({}, context, {
                        diagnostics: eslintDiagnostics
                    });
                    return next(document, range, newContext, token);
                },
                workspace: {
                    configuration: (params, _token, _next) => {
                        return params.items.map(item => {
                            let uri = item.scopeUri;
                            let config = coc_nvim_1.workspace.getConfiguration('eslint', uri);
                            let pm = config.get('packageManager', 'npm');
                            let settings = {
                                packageManager: pm === 'yarn' ? 'yarn' : 'npm',
                                validate: config.get('validate', true),
                                autoFix: config.get('autoFix', false),
                                autoFixOnSave: config.get('autoFixOnSave', false),
                                nodePath: config.get('nodePath', undefined),
                                options: config.get('options', {}),
                                run: config.get('run', 'onType'),
                                workspaceFolder: coc_nvim_1.workspace.workspaceFolder,
                                workingDirectory: undefined
                            };
                            return settings;
                        });
                    }
                }
            }
        };
        let client = new coc_nvim_1.LanguageClient('eslint', 'eslint langserver', serverOptions, clientOptions);
        subscriptions.push(coc_nvim_1.services.registLanguageClient(client));
        function onDidChangeConfiguration(e) {
            if (!e.affectsConfiguration('eslint'))
                return;
            if (client.serviceState != coc_nvim_1.ServiceStat.Running)
                return;
            for (let textDocument of syncedDocuments.values()) {
                if (!shouldBeValidated(textDocument)) {
                    syncedDocuments.delete(textDocument.uri);
                    client.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, { textDocument: { uri: textDocument.uri } });
                }
            }
            for (let textDocument of coc_nvim_1.workspace.textDocuments) {
                if (!syncedDocuments.has(textDocument.uri.toString()) && shouldBeValidated(textDocument)) {
                    client.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, {
                        textDocument: {
                            uri: textDocument.uri,
                            languageId: textDocument.languageId,
                            version: textDocument.version,
                            text: textDocument.getText()
                        }
                    });
                    syncedDocuments.set(textDocument.uri.toString(), textDocument);
                }
            }
        }
        subscriptions.push(coc_nvim_1.commands.registerCommand('eslint.createConfig', createDefaultConfiguration));
        subscriptions.push(coc_nvim_1.commands.registerCommand('eslint.executeAutofix', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let document = yield coc_nvim_1.workspace.document;
            let textDocument = {
                uri: document.uri,
                version: document.version
            };
            let params = {
                command: 'eslint.applyAutoFix',
                arguments: [textDocument]
            };
            client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params)
                .then(undefined, () => {
                coc_nvim_1.workspace.showMessage('Failed to apply ESLint fixes to the document.', 'error');
            });
        })));
        client.onReady().then(() => {
            client.onNotification(exitCalled, params => {
                coc_nvim_1.workspace.showMessage(`Server process exited with code ${params[0]}. This usually indicates a misconfigured ESLint setup.`, 'error');
            });
            client.onRequest(NoConfigRequest.type, params => {
                let document = vscode_uri_1.default.parse(params.document.uri);
                let fileLocation = document.fsPath;
                coc_nvim_1.workspace.showMessage(`No ESLint configuration (e.g .eslintrc) found for file: ${fileLocation}`, 'warning');
                return {};
            });
            client.onRequest(NoESLintLibraryRequest.type, params => {
                let uri = vscode_uri_1.default.parse(params.source.uri);
                coc_nvim_1.workspace.showMessage(`Failed to load the ESLint library for the document ${uri.fsPath}`, 'warning');
                return {};
            });
            coc_nvim_1.workspace.onDidChangeConfiguration(onDidChangeConfiguration, null, subscriptions);
        }, _e => {
            // noop
        });
    });
}
exports.activate = activate;
//# sourceMappingURL=index.js.map